#include "form.nvgt"
#include "ini.nvgt"

atomic_bool program_exit = false;
class message_queue {
	json_object@[] message_queue;
	fast_mutex message_queue_mutex;
	void enqueue_message(json_object@ msg) {
		fast_mutex_lock scoped(message_queue_mutex);
		message_queue.insert_last(msg);
	}
	json_object@ dequeue_message() {
		fast_mutex_lock scoped(message_queue_mutex);
		if (message_queue.length() < 1) return null;
		json_object@ r = message_queue[0];
		message_queue.remove_at(0);
		return r;
	}
}
message_queue recv_queue;
message_queue send_queue;

web_socket@ ws;
void socket_thread() {
	json_object parse_fail;
	parse_fail["error"] = "received invalid message from server";
	try {
		http_client cl(config.get_string("", "host", "127.0.0.1"), config.get_double("", "port", 7774));
		http_request req(HTTP_GET, "/");
		http_response resp;
		@ws = web_socket(cl, req, resp);
		int flags;
		ws.send_frame("""{"user": 1}""");
		while(program_exit == false) {
			json_object@ msg_to_send = null;
			while ((@msg_to_send = send_queue.dequeue_message()) != null) {
				ws.send_frame(msg_to_send.stringify());
			}
			if (ws.poll(timespan(5000), SOCKET_SELECT_READ)) {
				string frame = ws.receive_frame(flags);
				if ((flags & WS_FRAME_OP_BITMASK) == WS_FRAME_OP_CLOSE or frame == "") {
					ws.shutdown();
					break;
				} else if ((flags & WS_FRAME_OP_BITMASK) == WS_FRAME_OP_PING) {
					ws.send_frame("", WS_FRAME_OP_PONG);
					continue;
				}
				json_object@ o;
				try {
					@o = parse_json(frame);
				} catch { recv_queue.enqueue_message(parse_fail); }
				recv_queue.enqueue_message(o);
			}
		}
	} catch {
		recv_queue.enqueue_message(null);
	}
}

void send_request(const string&in text, int id) {
	json_object result;
	result["id"] = id;
	result["user"] = 1;
	string[]@ raw_lines = text.split("\r\n", false);
	if (id == render_ID) {
		item_count = raw_lines.length();
		form.set_caption(f_render, "Cancel");
		play("begin");
	}
	json_array lines;
	for (uint i = 0; i < raw_lines.length(); i++) lines.add(raw_lines[i]);
	result["request"] = lines;
	send_queue.enqueue_message(result);
}

audio_form form;
sound demo;
ini config("STAR.ini");
int render_count = 0, item_count = 0;
int f_voices, f_script, f_render, f_exit;
int render_ID = 0x7fff;
int demo_ID = 0xffff;
void main() {
	async<void>(socket_thread);
	show_window("STAR client");
	form.create_window();
	wait(200);
	f_voices = form.create_list("available &voices");
	f_script = form.create_input_box("enter &script", multiline:true);
	f_render = form.create_button("&render to wav", true);
	f_exit = form.create_button("e&xit", false, true);
	form.focus(f_script);
	while(!form.is_pressed(f_exit)) {
		wait(5);
		if (form.get_current_focus() == f_script and (keyboard_modifiers & KEYMOD_CTRL) != 0) {
			int dir = 0;
			if (key_pressed(KEY_UP)) dir = -1;
			else if (key_pressed(KEY_DOWN)) dir = 1;
			if (dir != 0 and form.set_line(f_script, form.get_line_number(f_script) + dir)) {
				const string text = form.get_text_reference(f_script);
				int line_start = form.get_text_cursor(f_script);
				int line_end;
				for(line_end = line_start; line_end < text.length() and text[line_end] != "\n"; line_end++);
				send_request(text.substr(line_start, line_end -line_start), demo_ID);
			}
		}
		form.monitor();
		if (form.is_pressed(f_render)) {
			if (render_count > 0) {
				speak("Rendering in progress, will add canceling ability soon");
				continue;
			}
			string text = form.get_text(f_script);
			send_request(text, render_ID);
		}
		json_object@ msg = recv_queue.dequeue_message();
		if (@msg == null) continue;
		if (msg.exists("voices")) {
			play("ready");
			json_array@ v = msg["voices"];
			for (uint i = 0; i < v.length(); i++) form.add_list_item(f_voices, v[i]);
		} else if(msg.exists("speech")) {
			string[]@ id_parts = string(msg["speech"]).split("_");
			bool rendering = parse_int(id_parts[1]) == render_ID;
			if (rendering) {
				render_count++;
				if (render_count < item_count) play("progress", pitch = float(render_count / item_count) * 120);
				else {
					play("complete");
					form.set_caption(f_render, "&Render to wav");
					item_count = render_count = 0;
				}
				if (!directory_exists("output")) directory_create("output");
				file_put_contents("output/" + id_parts[2] + ".wav", string_base64_decode(msg["data"]));
			} else {
				demo.close();
				demo.push_memory(string_base64_decode(msg["data"]), true);
				demo.play();
			}
		} else if (msg.exists("warning")) {
			play("warning");
			if (item_count > 0) render_count++;
			speak(msg["warning"], false);
		}
	}
	program_exit = true;
}

sound@[] g_sounds;
enum sound_flags { SOUND_LOOPING, SOUND_PAUSED }
sound@ play(const string&in filename, int64 flags = 0, double pitch = 100) {
	sound s;
	if (!s.load("audio/" + filename + ".ogg")) return null;
	s.pitch = pitch;
	if (flags & SOUND_PAUSED == 0)
		flags & SOUND_LOOPING > 0? s.play_looped() : s.play();
	for (uint i = 0; i < g_sounds.length(); i++) {
		if (g_sounds[i].playing or g_sounds[i].paused) continue;
		g_sounds.remove_at(i);
		i--;
	}
	g_sounds.insert_last(s);
	return s;
}
